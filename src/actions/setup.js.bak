import fs from 'fs-extra';
import path from 'path';
import spawn from 'cross-spawn';
import readPkgUp from 'read-pkg-up';
import { hasFile, appDir, has, runTask } from '../utils';

export async function setup(tool, opts) {
	if (!hasFile('.git')) {
		await runTask('Initialize empty git repository', spinner => {
			runCMD(['git', 'init'], {
				error: 'Error initializing empty git repository',
			});
			spinner.text = 'Initialized empty git repository';
		});
	}

	await runTask('Create .gitignore', async spinner => {
		await createFileFrom('.gitignore', { file: 'lib/gitignore' });
		spinner.text = `Created .gitignore`;
	});

	// Create our Taskfile.sh and make it executable
	let taskFilePath = false;
	await runTask('Create Taskfile.sh', async spinner => {
		taskFilePath = await createFileFrom('Taskfile.sh', {
			file: 'lib/Taskfile.sh',
		});
		spinner.text = `Created Taskfile.sh`;
	});

	if (taskFilePath != null) {
		await runTask('Changing access permisson to +x on Taskfile.sh', spinner => {
			runCMD(['chmod', '+x', taskFilePath], {
				error: 'Error changing access permission on Taskfile.sh',
			});
			spinner.text = 'Changed access permisson to +x on Taskfile.sh';
		});
	}

	//////////////////////////////////////////////////////////////////////////////
	// eslint + prettier option

	if (tool.includes('eslint_prettier')) {
		// (1) Update package.json and add `eslintConfig` and `prettier` properties
		await runTask('Add eslint+prettier configuration', async spinner => {
			spinner.text = 'Add @jvdx/prettier-config-jvdx';
			await updatePkgJson('prettier', '@jvdx/prettier-config-jvdx');

			spinner.text = 'Add @jvdx/eslint-config-jvdx';
			await updatePkgJson('eslintConfig', {
				extends: '@jvdx/eslint-config-jvdx',
			});

			spinner.text = 'Added eslint+prettier configuration';
		});

		// (2) Update lint + format tasks in `Taskfile.sh`
		await runTask(
			'Update lint + format tasks in Taskfile.sh',
			async spinner => {
				await replaceInFile(
					'Taskfile.sh',
					/echo "Please setup your format task."[\s\S]*# jvdx format \$\*/g,
					'jvdx format $*',
				);
				await replaceInFile(
					'Taskfile.sh',
					/echo "Please setup your lint task."[\s\S]*# jvdx lint \$\*/g,
					'jvdx lint $*',
				);

				spinner.text = 'Updated lint + format tasks in Taskfile.sh';
			},
		);
	}

	//////////////////////////////////////////////////////////////////////////////
	// babel option

	if (tool.includes('babel')) {
		// (1) Update package.json and add `babel` property
		await runTask('Add babel configuration', async spinner => {
			spinner.text = 'Add @jvdx/babel-preset-jvdx';
			await updatePkgJson('babel', { presets: ['@jvdx/babel-preset-jvdx'] });
			spinner.text = 'Added babel configuration';
		});
	}
}

////////////////////////////////////////////////////////////////////////////////

function runCMD(commands, options) {
	const [bin, ...cmds] = commands;
	const stdout = spawn.sync(bin, cmds, { stdio: options.stdio || 'ignore' });

	if (stdout.status !== 0) {
		throw new Error(options.error);
	}
}

////////////////////////////////////////////////////////////////////////////////

const here = (...p) => path.join(__dirname, ...p);

const hereRelative = (...p) => here(...p).replace(process.cwd(), '.');

async function createFileFrom(target, source) {
	if (hasFile(target)) {
		const err = new Error(`Skip creation of ${target} (already exists)`);
		err.fail = false;
		throw err;
	}

	if (source.file == null && source.data == null) {
		const err = new Error(`Skip creation of ${target} (content missing)`);
		err.fail = false;
		throw err;
	}

	const root = appDir();
	const dest = path.resolve(root, target);
	const content = source.file
		? fs.readFileSync(hereRelative(source.file))
		: source.data;

	try {
		await fs.outputFile(dest, content);
		return dest;
	} catch (err) {
		const error = new Error(`Skip creation of ${target} (${err.message})`);
		error.fail = true;
		throw error;
	}
}

////////////////////////////////////////////////////////////////////////////////

async function updatePkgJson(key, value) {
	const { packageJson, path } = await readPkgUp({ normalize: false });

	if (has(packageJson, key)) {
		const err = new Error(`Skip updating package.json (already updated)`);
		err.fail = false;
		throw err;
	}

	const newJSON = {
		...packageJson,
		[key]: value,
	};

	try {
		await fs.writeJson(path, newJSON, { spaces: 2 });
	} catch (err) {
		const error = new Error(`Skip updating package.json (${err.message})`);
		error.fail = true;
		throw error;
	}
}

////////////////////////////////////////////////////////////////////////////////

async function replaceInFile(target, from, to) {
	const filePath = path.resolve(appDir(), target);
	let oldContent = '';
	try {
		oldContent = await fs.readFile(filePath, 'utf8');
	} catch (err) {
		const error = new Error(
			`Skip replacing content of "${target}" (${err.message})`,
		);
		error.fail = true;
		throw error;
	}

	const newContent = oldContent.replace(from, to);

	if (newContent === oldContent) {
		const error = new Error(
			`Skip replacing content of "${target}" (already exists)`,
		);
		error.fail = false;
		throw error;
	}

	try {
		await fs.writeFile(filePath, newContent, 'utf8');
	} catch (err) {
		const error = new Error(
			`Skip replacing content of "${target}" (${err.message})`,
		);
		error.fail = true;
		throw error;
	}
}
